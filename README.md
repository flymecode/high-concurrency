#缓存的作用
cup的频率很快，为了缓解cpu和内存之间速度不匹配的问题

#cup多级缓存
cup cache 有什么意义？
- 时间局部性：如果某个数据被访问，那么在不久的将来它很可能被再次访问
- 空间局部行：如果某个数据被访问，那么与它相邻的数据很快也可能被访问

#cup多级缓存-缓存一致性 MESI
用于保证多个cpu cache之间共享数据的一致性
M : 该缓存行允许缓存在cpu中

#cup多级缓存-重排序优化
处理器为了提高运算速度而做出违背代码原有顺序的优化。

Java内存模型是一种规范，规范了Java虚拟机如何与操作系统内存之间协同工作的，规范了一个线程如何和何时能够看到另外一个线程修改共享变量的数值，如何同步的
访问共享变量的数值。 

#Java内存模型-同步操作与规则 

Lock   --> read  --> load  --> use 

主内存 <-> save/load <->工作内存 <-> Java线程

unLock <-- write <-- store <-- assign

1. read 和load，store和write 必须安装顺序执行，中间可以有其它指令，但是不能单一出现
2. 不允许一个线程丢弃它最近的assign操作，保证一个线程的assign操作必须同步给主内存
3. 一个新的变量必须从主内存中产生
4. lock操作只能由一个线程获得，当获取lock的线程可以获取多次
5. 当一个变量执行lock操作，那么会清空工作内存中的值
6. 当一个变量执行lock之前，会把工作内存中的值，同步到主内存中


#并发的优势与风险
速度：同时处理更多个请求，响应更快，复杂的操作可以分成多个进程进行
设计：程序设计更加简单
资源利用：CPU能够在等待IO的时候，做一些其他的事情，提高CPU的利用率

安全性：多个线程中共享数据的时候，可能产生不符合预期的值
活跃性：某个操作无法继续进行下去，比如死锁和饥饿现象
性能：线程过多时会是的CPU频繁切换，调度时间增多，同步机制，消耗过多的内存

#线程安全
当多个线程访问某个类的时候，不管运行时环境采用何种调度方式，或者这些进程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确
的行为，那么就称这个类是线程安全的。

原子性：提供了互斥访问，同一时刻只能有一个线程来对它进行操作
可见性：一个线程对主内存的修改，可以及时的被其他的线程观察到
有序性：一个线程观察其他线程中执行的指令的顺序，由于指令重排序的存在，该观察结果一般是杂乱无序的

#Atomic包：原子性 CAS ，更新失败之后循环尝试

内存值 期望值 更新的值
如果更新的值与期望的值相等，就更新。
主内存和工作内存

AtomicLong 与 LongAdder

LongAdder在线程并发对的采用

AtomicReference

AtomicStampReference 解决ABA问题



