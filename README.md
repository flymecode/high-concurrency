#缓存的作用
cup的频率很快，为了缓解cpu和内存之间速度不匹配的问题

#cup多级缓存
cup cache 有什么意义？
- 时间局部性：如果某个数据被访问，那么在不久的将来它很可能被再次访问
- 空间局部行：如果某个数据被访问，那么与它相邻的数据很快也可能被访问

#cup多级缓存-缓存一致性 MESI
用于保证多个cpu cache之间共享数据的一致性
M : 该缓存行允许缓存在cpu中

#cup多级缓存-重排序优化
处理器为了提高运算速度而做出违背代码原有顺序的优化。

Java内存模型是一种规范，规范了Java虚拟机如何与操作系统内存之间协同工作的，规范了一个线程如何和何时能够看到另外一个线程修改共享变量的数值，如何同步的
访问共享变量的数值。 

#Java内存模型-同步操作与规则 

Lock   --> read  --> load  --> use 

主内存 <-> save/load <->工作内存 <-> Java线程

unLock <-- write <-- store <-- assign

1. read 和load，store和write 必须安装顺序执行，中间可以有其它指令，但是不能单一出现
2. 不允许一个线程丢弃它最近的assign操作，保证一个线程的assign操作必须同步给主内存
3. 一个新的变量必须从主内存中产生
4. lock操作只能由一个线程获得，当获取lock的线程可以获取多次
5. 当一个变量执行lock操作，那么会清空工作内存中的值
6. 当一个变量执行lock之前，会把工作内存中的值，同步到主内存中


#并发的优势与风险
速度：同时处理更多个请求，响应更快，复杂的操作可以分成多个进程进行
设计：程序设计更加简单
资源利用：CPU能够在等待IO的时候，做一些其他的事情，提高CPU的利用率

安全性：多个线程中共享数据的时候，可能产生不符合预期的值
活跃性：某个操作无法继续进行下去，比如死锁和饥饿现象
性能：线程过多时会是的CPU频繁切换，调度时间增多，同步机制，消耗过多的内存

#线程安全
当多个线程访问某个类的时候，不管运行时环境采用何种调度方式，或者这些进程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确
的行为，那么就称这个类是线程安全的。

原子性：提供了互斥访问，同一时刻只能有一个线程来对它进行操作
可见性：一个线程对主内存的修改，可以及时的被其他的线程观察到
有序性：一个线程观察其他线程中执行的指令的顺序，由于指令重排序的存在，该观察结果一般是杂乱无序的

#Atomic包：原子性 CAS ，更新失败之后循环尝试

内存值 期望值 更新的值
如果更新的值与期望的值相等，就更新。
主内存和工作内存

AtomicLong 与 LongAdder

LongAdder在线程并发对的采用

AtomicReference

AtomicStampReference 解决ABA问题

#锁

synchronized:关键字，依赖JVM 不可中断的锁，适合不激烈，可读性比较好
Lock:依赖特殊的CPU指令，代码实现ReentrantLock可中断，多样化同步，竞争激烈时能维持常态
Atomic:竞争激烈时能维持常态，比Lock性能好；只能同步一个值

#可见性

导致共享变量在线程间不可见的的原因

线程交叉执行
重排序和线程交叉执行
共享变量更新之后没有在工作内存与主存间及时更新

JMM关于synchronized的两条规定
线程解锁前，必须把共享变量的最新值刷新到主内存中
线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量的时候从主内存中重新获取最新的值
加锁和解锁是同一把锁

可见性 volatile
不具有原子性，
通过加入内存屏障和禁止重排序优化来实现

对volatitle 变量写操作时，会在写操作后加入一条store屏障指令，将本地内存中的共享变量值刷新到主内存

对volatitle 变量读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量

普通读

普通写

StoreStore 禁止上面的普通写和volatile写重排序

Volatile写

StoreLoad 防止上面的volatile与下面可能有的volatile读/写重排序

---
volatile读

LoadLoad 禁止下面所有的普通读操作和上面的volatile读重排序

LoadStore 禁止下面所有的写操作和上面的volatile读重排序

普通写

普通读

使用场景：
对变量的写作操作不依赖与当前值

适合用做标识值

double check
```java
volatile boolean inited = false;
// 线程1：
context = loadContext();
inited = true;
// 线程2
while(!inited) {
    sleep();
}
doSomethingWithConfig(context);
```

Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到
多线程并发执行的正确性。
#有序性
happen before 原则

程序次序原则：一个线程内，按照代码书序，书写在前面的操作先行发生在书写在后面的操作

锁定规则：一个Lock操作，先行发生与后面一个锁的lock操作

volatile变量规则：对一个变量的写操作，先行发生与后面对这个变量的读操作

传递规则：如果操作A先行发生与操作B，而操作B又先行发生与操作C,则可以得出操作A先行
发生与操作C

线程中断规则：对象成interrput()方法的调用先行发生与被中断线程的代码检测到中断事件的发生

线程终结规则：线程中所有的操作都先行发生与线程的终止检测，我们可以通过Thread.join()方法结束。
Thread.isAlive()的返回值手段检测到线程已经终止执行

对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始


发布对象：使一个对象能够被当前范围之外的代码使用

对象溢出：一种错误的发布，当一个对象还没有构造完成时候，就使它被其他线程所见
#线程池未完成....

可以使用top命令分析CPU使用，内存使用，负载等情况
可以使用free查看内存整体的使用情况
可以使用cat /proc/meminfo查看内存更详细的情况/

- 在静态初始化函数中初始化一个对象引用

- 将对象引用保存到volatile类型域或者AtomicReference对象中

- 将对象的引用保存到某个正确构造对象的final类型域中

- 将对象的引用保存到一个由锁保护的域中

# 不可变的对象

对象创建以后的状态都是不可变的

对象所有域都是final类型

对象是正确创建的，在对象创建期间，this没有溢出

final:类、方法、变量

- 修饰类：不能被继承
- 修饰方法：锁定方法不能被继承，效率
- 修饰变量：基本数据类型变量，引用变量

# 线程封闭
堆栈封闭：局部变量，无并发问题
ThreadLocal线程封闭: 特别好的封闭方法
ThreadLocal内部维护一个Map，key为线程对象，value为保存的值
数据库连接对应的conection对象

#线程不安全的类
simpledateformate
stringbuilder
hashmap
hashset
arraylist

// 先检查后执行，在线程共享的时候应该考虑这个判断的标准是不是线程共享的
if(condition(a)) {handle(a)}
# 同步容器主要采用synchronized来实现，并不能保证并发安全
如果我们使用foreach 和 使用迭代器遍历的同时最好不要执行删除操作。
这样会导致ConcurrentModificationException
在找到需要删除的数值我们做好标记就可以了，在循环之后执行删除

# 并发容器 JUC
ArrayList -> CopyOnWriteArrayList

- 写操作，消耗内存
- 不能实时性要求

适合读多写少的操作

ConcurrentHashMap

ConcurrentSkipListMap 键是排序的


安全共享对象策略

线程限制：一个被线程限制的对象，由线程独占，并且只能被占有它的线程修改

共享只读：一个共享只读对象，在没有额外同步的情况下，可以被多个线程并发访问，但是任何线程都不能修改它

线程安全对象：

被守护的对象：被搜狐的对象只能通过获取特定的锁来访问

# AbstractQueuedSynchronizer AQS
sync queue
双向链表
使用Node来实现FIFO队列，可以用来构建锁或者其他的同步容器的基础框架
利用int来表示状态
使用方法为继承

子类通过继承并通过实现它的方法管理其状态{acquire 和 release } 的方法操纵状态
可以同时实现排它锁和共享锁模式（独占，共享）

AQS实现的大致思路：
AQS内部维护了一个clh队列来管理锁，线程会首先尝试获取锁，如果没有获取到，将该线程和等待信息包装为一个node
节点，加入到同步队列

AQS组件

CountDownLatch 闭锁
Semaphore
CycBarrier 
ReentrantLock
Condition
FutureTask

Condition类，可以分组唤醒需要唤醒的线程


